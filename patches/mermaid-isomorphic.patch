diff --git a/dist/mermaid-isomorphic.js b/dist/mermaid-isomorphic.js
index aa5dc09a5dfb58a98d3f12cd2fc473caddd97b0d..710651c1e91208ed659c4587f1b44654ed96c775 100644
--- a/dist/mermaid-isomorphic.js
+++ b/dist/mermaid-isomorphic.js
@@ -1,11 +1,13 @@
-import { chromium } from 'playwright';
-const html = import.meta.resolve('../index.html');
+import { createRequire } from "node:module";
+import { chromium } from "playwright";
+const require = createRequire(import.meta.url);
+const html = require.resolve("../index.html");
 const mermaidScript = {
-    url: import.meta.resolve('mermaid/dist/mermaid.js')
+	url: require.resolve("mermaid/dist/mermaid.js"),
 };
 const faStyle = {
-    // We use url, not path. If we use path, the fonts can’t be resolved.
-    url: import.meta.resolve('@fortawesome/fontawesome-free/css/all.css')
+	// We use url, not path. If we use path, the fonts can’t be resolved.
+	url: require.resolve("@fortawesome/fontawesome-free/css/all.css"),
 };
 /* c8 ignore start */
 /**
@@ -17,74 +19,75 @@ const faStyle = {
  *   A settled promise that holds the rendering results.
  */
 async function renderDiagrams({ containerStyle, diagrams, mermaidConfig, prefix, screenshot }) {
-    await Promise.all(Array.from(document.fonts, (font) => font.load()));
-    const parser = new DOMParser();
-    const serializer = new XMLSerializer();
-    const container = document.createElement('div');
-    container.ariaHidden = 'true';
-    container.style.maxHeight = '0';
-    container.style.opacity = '0';
-    container.style.overflow = 'hidden';
-    Object.assign(container.style, containerStyle);
-    document.body.append(container);
-    mermaid.initialize(mermaidConfig);
-    /**
-     * Get an aria value form a referencing attribute.
-     *
-     * @param element
-     *   The SVG element the get the value from.
-     * @param attribute
-     *   The attribute whose value to get.
-     * @returns
-     *   The aria value.
-     */
-    // eslint-disable-next-line unicorn/consistent-function-scoping
-    function getAriaValue(element, attribute) {
-        const value = element.getAttribute(attribute);
-        if (!value) {
-            return;
-        }
-        let result = '';
-        for (const id of value.split(/\s+/)) {
-            const node = element.getElementById(id);
-            if (node) {
-                result += node.textContent;
-            }
-        }
-        return result;
-    }
-    return Promise.allSettled(diagrams.map(async (diagram, index) => {
-        const id = `${prefix}-${index}`;
-        try {
-            const { svg } = await mermaid.render(id, diagram, container);
-            const root = parser.parseFromString(svg, 'text/html');
-            const [element] = root.getElementsByTagName('svg');
-            const { height, width } = element.viewBox.baseVal;
-            const description = getAriaValue(element, 'aria-describedby');
-            const title = getAriaValue(element, 'aria-labelledby');
-            if (screenshot) {
-                document.body.append(element);
-            }
-            const result = {
-                height,
-                id,
-                svg: serializer.serializeToString(element),
-                width
-            };
-            if (description) {
-                result.description = description;
-            }
-            if (title) {
-                result.title = title;
-            }
-            return result;
-        }
-        catch (error) {
-            throw error instanceof Error
-                ? { name: error.name, stack: error.stack, message: error.message }
-                : error;
-        }
-    }));
+	await Promise.all(Array.from(document.fonts, (font) => font.load()));
+	const parser = new DOMParser();
+	const serializer = new XMLSerializer();
+	const container = document.createElement("div");
+	container.ariaHidden = "true";
+	container.style.maxHeight = "0";
+	container.style.opacity = "0";
+	container.style.overflow = "hidden";
+	Object.assign(container.style, containerStyle);
+	document.body.append(container);
+	mermaid.initialize(mermaidConfig);
+	/**
+	 * Get an aria value form a referencing attribute.
+	 *
+	 * @param element
+	 *   The SVG element the get the value from.
+	 * @param attribute
+	 *   The attribute whose value to get.
+	 * @returns
+	 *   The aria value.
+	 */
+	// eslint-disable-next-line unicorn/consistent-function-scoping
+	function getAriaValue(element, attribute) {
+		const value = element.getAttribute(attribute);
+		if (!value) {
+			return;
+		}
+		let result = "";
+		for (const id of value.split(/\s+/)) {
+			const node = element.getElementById(id);
+			if (node) {
+				result += node.textContent;
+			}
+		}
+		return result;
+	}
+	return Promise.allSettled(
+		diagrams.map(async (diagram, index) => {
+			const id = `${prefix}-${index}`;
+			try {
+				const { svg } = await mermaid.render(id, diagram, container);
+				const root = parser.parseFromString(svg, "text/html");
+				const [element] = root.getElementsByTagName("svg");
+				const { height, width } = element.viewBox.baseVal;
+				const description = getAriaValue(element, "aria-describedby");
+				const title = getAriaValue(element, "aria-labelledby");
+				if (screenshot) {
+					document.body.append(element);
+				}
+				const result = {
+					height,
+					id,
+					svg: serializer.serializeToString(element),
+					width,
+				};
+				if (description) {
+					result.description = description;
+				}
+				if (title) {
+					result.title = title;
+				}
+				return result;
+			} catch (error) {
+				throw error instanceof Error
+					? { name: error.name, stack: error.stack, message: error.message }
+					: error;
+			}
+		}),
+	);
 }
 /**
  * Launch a browser and a single browser context.
@@ -97,17 +100,17 @@ async function renderDiagrams({ containerStyle, diagrams, mermaidConfig, prefix,
  *   A simple browser context wrapper
  */
 async function getBrowser(browserType, launchOptions) {
-    const browser = await browserType.launch(launchOptions);
-    const context = await browser.newContext({ bypassCSP: true });
-    return {
-        async close() {
-            await context.close();
-            await browser.close();
-        },
-        newPage() {
-            return context.newPage();
-        }
-    };
+	const browser = await browserType.launch(launchOptions);
+	const context = await browser.newContext({ bypassCSP: true });
+	return {
+		async close() {
+			await context.close();
+			await browser.close();
+		},
+		newPage() {
+			return context.newPage();
+		},
+	};
 }
 /**
  * Create a Mermaid renderer.
@@ -122,70 +125,68 @@ async function getBrowser(browserType, launchOptions) {
  *   A function that renders Mermaid diagrams in the browser.
  */
 export function createMermaidRenderer(options = {}) {
-    const { browserType = chromium, launchOptions } = options;
-    let browserPromise;
-    let count = 0;
-    return async (diagrams, renderOptions) => {
-        count += 1;
-        if (!browserPromise) {
-            browserPromise = getBrowser(browserType, launchOptions);
-        }
-        const context = await browserPromise;
-        let page;
-        let renderResults;
-        try {
-            page = await context.newPage();
-            await page.goto(html);
-            const promises = [page.addStyleTag(faStyle), page.addScriptTag(mermaidScript)];
-            const css = renderOptions?.css;
-            if (typeof css === 'string' || css instanceof URL) {
-                promises.push(page.addStyleTag({ url: String(css) }));
-            }
-            else if (css) {
-                for (const url of css) {
-                    promises.push(page.addStyleTag({ url: String(url) }));
-                }
-            }
-            await Promise.all(promises);
-            renderResults = await page.evaluate(renderDiagrams, {
-                // Avoid error TS2589: Type instantiation is excessively deep and possibly infinite.
-                containerStyle: (renderOptions?.containerStyle ?? {}),
-                diagrams,
-                screenshot: Boolean(renderOptions?.screenshot),
-                mermaidConfig: {
-                    fontFamily: 'arial,sans-serif',
-                    ...renderOptions?.mermaidConfig
-                },
-                prefix: renderOptions?.prefix ?? 'mermaid'
-            });
-            if (renderOptions?.screenshot) {
-                for (const result of renderResults) {
-                    if (result.status === 'fulfilled') {
-                        result.value.screenshot = await page
-                            .locator(`#${result.value.id}`)
-                            .screenshot({ omitBackground: true });
-                    }
-                }
-            }
-        }
-        finally {
-            await page?.close();
-            count -= 1;
-            if (!count) {
-                browserPromise = undefined;
-                context.close();
-            }
-        }
-        for (const result of renderResults) {
-            if (result.status !== 'rejected') {
-                continue;
-            }
-            const { reason } = result;
-            if (reason && 'name' in reason && 'message' in reason && 'stack' in reason) {
-                Object.setPrototypeOf(reason, Error.prototype);
-            }
-        }
-        return renderResults;
-    };
+	const { browserType = chromium, launchOptions } = options;
+	let browserPromise;
+	let count = 0;
+	return async (diagrams, renderOptions) => {
+		count += 1;
+		if (!browserPromise) {
+			browserPromise = getBrowser(browserType, launchOptions);
+		}
+		const context = await browserPromise;
+		let page;
+		let renderResults;
+		try {
+			page = await context.newPage();
+			await page.goto(html);
+			const promises = [page.addStyleTag(faStyle), page.addScriptTag(mermaidScript)];
+			const css = renderOptions?.css;
+			if (typeof css === "string" || css instanceof URL) {
+				promises.push(page.addStyleTag({ url: String(css) }));
+			} else if (css) {
+				for (const url of css) {
+					promises.push(page.addStyleTag({ url: String(url) }));
+				}
+			}
+			await Promise.all(promises);
+			renderResults = await page.evaluate(renderDiagrams, {
+				// Avoid error TS2589: Type instantiation is excessively deep and possibly infinite.
+				containerStyle: renderOptions?.containerStyle ?? {},
+				diagrams,
+				screenshot: Boolean(renderOptions?.screenshot),
+				mermaidConfig: {
+					fontFamily: "arial,sans-serif",
+					...renderOptions?.mermaidConfig,
+				},
+				prefix: renderOptions?.prefix ?? "mermaid",
+			});
+			if (renderOptions?.screenshot) {
+				for (const result of renderResults) {
+					if (result.status === "fulfilled") {
+						result.value.screenshot = await page
+							.locator(`#${result.value.id}`)
+							.screenshot({ omitBackground: true });
+					}
+				}
+			}
+		} finally {
+			await page?.close();
+			count -= 1;
+			if (!count) {
+				browserPromise = undefined;
+				context.close();
+			}
+		}
+		for (const result of renderResults) {
+			if (result.status !== "rejected") {
+				continue;
+			}
+			const { reason } = result;
+			if (reason && "name" in reason && "message" in reason && "stack" in reason) {
+				Object.setPrototypeOf(reason, Error.prototype);
+			}
+		}
+		return renderResults;
+	};
 }
 //# sourceMappingURL=mermaid-isomorphic.js.map
diff --git a/src/mermaid-isomorphic.ts b/src/mermaid-isomorphic.ts
index 6e5720399c7e994855ca58adb29d73639e241172..07606ce55d1859441380e53b5f8f7b2cfc1f1309 100644
--- a/src/mermaid-isomorphic.ts
+++ b/src/mermaid-isomorphic.ts
@@ -1,15 +1,19 @@
+import { createRequire } from "node:module"
+
 import { type Mermaid, type MermaidConfig } from 'mermaid'
 import { type BrowserType, chromium, type LaunchOptions, type Page } from 'playwright'
 
+const require = createRequire(import.meta.url)
+
 declare const mermaid: Mermaid
 
-const html = import.meta.resolve('../index.html')
+const html = require.resolve('../index.html')
 const mermaidScript = {
-  url: import.meta.resolve('mermaid/dist/mermaid.js')
+  url: require.resolve('mermaid/dist/mermaid.js')
 }
 const faStyle = {
   // We use url, not path. If we use path, the fonts can’t be resolved.
-  url: import.meta.resolve('@fortawesome/fontawesome-free/css/all.css')
+  url: require.resolve('@fortawesome/fontawesome-free/css/all.css')
 }
 
 export interface CreateMermaidRendererOptions {
